{{- /* 
================================================================================
SEARCH BAR COMPONENT
================================================================================
Provides a centralized search interface with fuzzy search, keyboard navigation,
and quick suggestions.

USAGE:
{{template "search-bar" .}}

FEATURES:
- Fuzzy search using Fuse.js
- Keyboard navigation (arrow keys, enter, escape)
- Quick suggestions when focused with empty query
- Search result categories with color coding
- Prefetch on hover for performance
- Animated width expansion on focus
- Dark mode support
- Keyboard shortcut indicator (Cmd/Ctrl+K)

DATA STRUCTURE:
The component uses Alpine.js x-data with:
- query: Current search input
- results: Search results from Fuse.js
- fuse: Fuse.js instance
- showResults: Dropdown visibility
- selectedIndex: Keyboard navigation index
- loading: Loading state
- searchFocused: Focus state for width animation
- suggestions: Quick link suggestions
- showingSuggestions: Whether showing suggestions vs results

EVENTS:
Dispatches 'search-selected' event when a result or suggestion is selected,
allowing parent components to react (e.g., close mobile menu).

KEYBOARD SHORTCUTS:
- Cmd/Ctrl+K: Focus search input (handled by parent)
- Arrow Up/Down: Navigate results
- Enter: Select highlighted result
- Escape: Close dropdown

ANIMATION DETAILS:
- Width expansion: 18rem → 28rem on focus (300ms ease-out)
- Dropdown fade: 200ms enter, 150ms leave
- Smooth transitions for all states

STYLING:
- Positioned absolutely, centered horizontally
- Parent must provide relative positioning context
- Responsive: Hidden on mobile/tablet (lg:block)
- Uses brand colors for category badges

TECHNICAL NOTES:
- Loads search index from /searchIndex.json
- Debounced input (50ms) for performance
- Configurable Fuse.js weights for title/content/description
- Maximum 8 results displayed
- Blur delay (200ms) to allow click events

DEPENDENCIES:
- Alpine.js 3.x
- Fuse.js 7.0.0
- /searchIndex.json (generated by backend)
- /icons/sprite.svg (search, spinner icons)
*/ -}}
{{define "search-bar"}}
<div class="hidden lg:block 2xl:ml-80"
     x-data="{
         query: '',
         results: [],
         fuse: null,
         showResults: false,
         selectedIndex: -1,
         loading: false,
         searchFocused: false,
         isHovering: false,
         animationInterval: null,
         animatedPlaceholder: '',
         dotCount: 0,
         currentLang: '{{.Language}}',
         suggestions: {{toJSON (slice
            (dict "title" (t "search.suggestions.platform_overview.title") "url" "/platform/" "category" "Feature" "icon" "grid" "description" (t "search.suggestions.platform_overview.description"))
            (dict "title" (t "search.suggestions.features.title") "url" "/platform/features/" "category" "Feature" "icon" "star" "description" (t "search.suggestions.features.description"))
            (dict "title" (t "search.suggestions.documentation.title") "url" "/docs/start-guide/welcome" "category" "Docs" "icon" "book" "description" (t "search.suggestions.documentation.description"))
            (dict "title" (t "search.suggestions.api_reference.title") "url" "/api/start-guide/introduction" "category" "API" "icon" "code" "description" (t "search.suggestions.api_reference.description"))
            (dict "title" (t "search.suggestions.contact_us.title") "url" "/contact/" "category" "Page" "icon" "mail" "description" (t "search.suggestions.contact_us.description"))
         )}},
         showingSuggestions: false,
         async init() {
             try {
                 // Load language-specific search index
                 const indexFile = this.currentLang === 'en' ? '/searchIndex.json' : `/searchIndex-${this.currentLang}.json`;
                 const response = await fetch(indexFile);
                 const data = await response.json();
                 this.fuse = new Fuse(data, {
                     keys: [
                         { name: 'title', weight: 0.7 },
                         { name: 'content', weight: 0.3 },
                         { name: 'description', weight: 0.5 }
                     ],
                     threshold: 0.3,
                     includeScore: true,
                     includeMatches: true
                 });
                 
                 // Update suggestions URLs to include language prefix if needed
                 if (this.currentLang !== 'en') {
                     this.suggestions = this.suggestions.map(s => ({
                         ...s,
                         url: `/${this.currentLang}${s.url}`
                     }));
                 }
             } catch (error) {
                 console.error('Failed to load search index:', error);
             }
         },
         showSuggestions() {
             if (!this.query.trim()) {
                 this.showingSuggestions = true;
                 this.showResults = true;
                 this.results = [];
                 this.selectedIndex = -1;
             }
         },
         search() {
             if (!this.query.trim()) {
                 // If query is empty, show suggestions instead
                 this.showingSuggestions = true;
                 this.results = [];
                 this.showResults = true;
                 this.selectedIndex = -1;
                 return;
             }
             
             this.showingSuggestions = false;
             if (!this.fuse) {
                 this.results = [];
                 this.showResults = false;
                 return;
             }
             
             this.loading = true;
             let results = this.fuse.search(this.query);
             
             // Sort by category preference when scores are similar
             const categoryOrder = { 'Feature': 1, 'Docs': 2, 'API': 3 };
             results.sort((a, b) => {
                 // If scores are very close (within 0.05), sort by category preference
                 if (Math.abs(a.score - b.score) < 0.05) {
                     const orderA = categoryOrder[a.item.category] || 999;
                     const orderB = categoryOrder[b.item.category] || 999;
                     return orderA - orderB;
                 }
                 // Otherwise sort by score (lower is better in Fuse.js)
                 return a.score - b.score;
             });
             
             this.results = results.slice(0, 8);
             this.showResults = true;
             this.selectedIndex = -1;
             this.loading = false;
         },
         selectResult(result) {
             // First hide the dropdown
             this.showResults = false;
             // Then animate search bar back after dropdown fade completes
             setTimeout(() => {
                 this.searchFocused = false;
                 this.query = '';
             }, 150);
             // Navigate after all animations complete (150ms dropdown + 300ms search bar = 450ms total)
             setTimeout(async () => {
                 // Create a temporary link element to use SPA navigation
                 const link = document.createElement('a');
                 link.href = result.item.url;
                 if (window.SPAUtils) {
                     await window.SPAUtils.handleNavigation(link);
                 } else {
                     window.location.href = result.item.url;
                 }
             }, 450);
         },
         selectSuggestion(suggestion) {
             // First hide the dropdown
             this.showResults = false;
             // Then animate search bar back after dropdown fade completes
             setTimeout(() => {
                 this.searchFocused = false;
                 this.query = '';
             }, 150);
             // Navigate after all animations complete (150ms dropdown + 300ms search bar = 450ms total)
             setTimeout(async () => {
                 // Create a temporary link element to use SPA navigation
                 const link = document.createElement('a');
                 link.href = suggestion.url;
                 if (window.SPAUtils) {
                     await window.SPAUtils.handleNavigation(link);
                 } else {
                     window.location.href = suggestion.url;
                 }
             }, 450);
         },
         getCategoryClass(category) {
             // Use brand colors from brand.html
             const categoryColors = {
                 // Blue Blue (#00A0D2) for Features
                 'Feature': 'bg-[#00A0D2]/10 text-[#00A0D2] dark:bg-[#00A0D2]/20 dark:text-[#00A0D2]',
                
                // Blue Blue (#00A0D2) for Platform (same as Feature)
                'Platform': 'bg-[#00A0D2]/10 text-[#00A0D2] dark:bg-[#00A0D2]/20 dark:text-[#00A0D2]',
                 
                 // Aquamarine (#A9F0D1) for Docs and Solutions - darker text for readability
                 'Docs': 'bg-green-100 text-green-800 dark:bg-green-900/20 dark:text-green-300',
                 'Solution': 'bg-[#A9F0D1]/20 text-green-700 dark:bg-[#A9F0D1]/20 dark:text-[#A9F0D1]',
                 
                 // Cyclamen (#F06C9B) for API
                 'API': 'bg-[#F06C9B]/10 text-[#F06C9B] dark:bg-[#F06C9B]/20 dark:text-[#F06C9B]',
                 
                 // Mustard (#FED766) for Insights - darker for readability
                 'Insights': 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900/20 dark:text-yellow-300',
                 
                 // Gray for Legal and Page
                 'Legal': 'bg-gray-100 text-gray-700 dark:bg-gray-800 dark:text-gray-300',
                 'Page': 'bg-gray-100 text-gray-700 dark:bg-gray-800 dark:text-gray-300'
             };
             return categoryColors[category] || 'bg-gray-100 text-gray-700 dark:bg-gray-800 dark:text-gray-300';
         },
         getSnippet(result) {
             const content = result.item.description || result.item.content || '';
             const queryWords = this.query.toLowerCase().split(' ');
             
             // Find first occurrence of query words
             let bestIndex = 0;
             for (let word of queryWords) {
                 const index = content.toLowerCase().indexOf(word);
                 if (index !== -1) {
                     bestIndex = Math.max(0, index - 40);
                     break;
                 }
             }
             
             const snippet = content.substring(bestIndex, bestIndex + 120);
             return bestIndex > 0 ? '...' + snippet + '...' : snippet + '...';
         },
         handleKeydown(event) {
             if (!this.showResults) return;
             
             const totalItems = this.showingSuggestions ? this.suggestions.length : this.results.length;
             
             if (event.key === 'ArrowDown') {
                 event.preventDefault();
                 this.selectedIndex = Math.min(this.selectedIndex + 1, totalItems - 1);
             } else if (event.key === 'ArrowUp') {
                 event.preventDefault();
                 this.selectedIndex = Math.max(this.selectedIndex - 1, -1);
             } else if (event.key === 'Enter' && this.selectedIndex >= 0) {
                 event.preventDefault();
                 if (this.showingSuggestions) {
                     this.selectSuggestion(this.suggestions[this.selectedIndex]);
                 } else {
                     this.selectResult(this.results[this.selectedIndex]);
                 }
             } else if (event.key === 'Escape') {
                 this.showResults = false;
                 this.showingSuggestions = false;
                 this.selectedIndex = -1;
                 this.searchFocused = false;
                 // Blur the input to remove focus
                 event.target.blur();
             }
         },
         getCategoryCounts() {
             const counts = {};
             const categoryOrder = ['Platform', 'Feature', 'Docs', 'API', 'Insights'];
             
             // Count results by category
             for (const result of this.results) {
                 const category = result.item.category;
                 if (category) {
                     counts[category] = (counts[category] || 0) + 1;
                 }
             }
             
             // Return ordered array of categories with counts
             return categoryOrder
                 .filter(cat => counts[cat] > 0)
                 .map(cat => ({ name: cat, count: counts[cat] }));
         },
         getCategoryTextClass(category) {
             // Return just the text color classes for the counter bar
             const textColors = {
                 'Feature': 'text-[#00A0D2] dark:text-[#00A0D2]',
                 'Platform': 'text-[#00A0D2] dark:text-[#00A0D2]',
                 'Docs': 'text-green-700 dark:text-green-400',
                 'API': 'text-[#F06C9B] dark:text-[#F06C9B]',
                 'Insights': 'text-yellow-700 dark:text-yellow-400'
             };
             return textColors[category] || 'text-gray-600 dark:text-gray-400';
         },
         getCategoryPlural(category, count) {
             // Handle proper pluralization for each category
             const plurals = {
                 'Feature': count === 1 ? 'Feature' : 'Features',
                 'Platform': count === 1 ? 'Platform' : 'Platform',
                 'Docs': count === 1 ? 'Doc' : 'Docs',
                 'API': count === 1 ? 'API' : 'APIs',
                 'Insights': count === 1 ? 'Insight' : 'Insights'
             };
             return plurals[category] || category;
         },
         startPlaceholderAnimation() {
             // Get the base placeholder text without dots
             const basePlaceholder = '{{t "search.placeholder_short"}}';
             const baseText = basePlaceholder.replace(/\.+$/, ''); // Remove trailing dots
             
             // Set initial animated placeholder
             this.animatedPlaceholder = baseText + '.';
             this.dotCount = 1;
             
             // Start the animation interval
             this.animationInterval = setInterval(() => {
                 this.dotCount = (this.dotCount % 3) + 1; // Cycle 1, 2, 3
                 this.animatedPlaceholder = baseText + '.'.repeat(this.dotCount);
             }, 500);
         },
         stopPlaceholderAnimation() {
             if (this.animationInterval) {
                 clearInterval(this.animationInterval);
                 this.animationInterval = null;
             }
             this.isHovering = false;
             this.dotCount = 0;
             this.animatedPlaceholder = '';
         }
     }"
     @click.away="showResults = false; searchFocused = false; showingSuggestions = false">
    <div class="relative transition-all duration-300 ease-out"
         :class="searchFocused ? 'w-[28rem]' : 'w-72'"
         @mouseenter="if (!searchFocused) { isHovering = true; startPlaceholderAnimation() }"
         @mouseleave="stopPlaceholderAnimation()">
        <div class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
            <svg class="w-4 h-4 text-gray-400" fill="currentColor">
                <use href="/icons/sprite.svg#search"></use>
            </svg>
        </div>
        <input 
            type="text" 
            x-model="query"
            @input.debounce.50ms="search()"
            @keydown="handleKeydown($event)"
            @focus="searchFocused = true; showSuggestions(); query && search()"
            @blur="setTimeout(() => { if (!showResults) searchFocused = false }, 200)"
            class="block w-full pl-10 pr-16 py-2 border border-transparent bg-gray-100 dark:bg-gray-800 rounded-lg text-sm placeholder-gray-400 dark:placeholder-gray-500 text-gray-900 dark:text-gray-100 focus:outline-none focus:bg-white dark:focus:bg-gray-700 focus:border-gray-200 dark:focus:border-gray-700 transition-all duration-300"
            :placeholder="isHovering && !searchFocused ? animatedPlaceholder : (searchFocused ? '{{t "search.placeholder_long"}}' : '{{t "search.placeholder_short"}}')"
            autocomplete="off"
            id="searchInput"
        >
        
        <!-- Keyboard shortcut indicator -->
        <div class="absolute inset-y-0 right-0 pr-3 flex items-center pointer-events-none space-x-1"
             x-data="{ isMac: navigator.userAgent.indexOf('Mac') !== -1 }">
            <span x-show="isMac" class="inline-flex items-center justify-center w-5 h-5 bg-gray-200 rounded text-xs font-bold text-gray-400 border border-gray-300">⌘</span>
            <span x-show="!isMac" class="inline-flex items-center justify-center w-7 h-5 bg-gray-200 rounded text-xs font-bold text-gray-400 border border-gray-300">Ctrl</span>
            <span class="inline-flex items-center justify-center w-5 h-5 bg-gray-200 rounded text-xs font-bold text-gray-400 border border-gray-300">K</span>
        </div>
        
        <!-- Search Results Dropdown -->
        <div x-show="showResults" 
             x-transition:enter="transition ease-out duration-200"
             x-transition:enter-start="opacity-0 translate-y-1"
             x-transition:enter-end="opacity-100 translate-y-0"
             x-transition:leave="transition ease-in duration-150"
             x-transition:leave-start="opacity-100 translate-y-0"
             x-transition:leave-end="opacity-0 translate-y-1"
             class="absolute top-full left-0 right-0 mt-2 bg-white dark:bg-gray-800 rounded-lg shadow-lg border border-gray-200 dark:border-gray-700 max-h-96 overflow-hidden z-50 flex flex-col">
            
            <!-- Scrollable content area -->
            <div class="flex-1 overflow-y-auto custom-scrollbar">
                <template x-if="loading">
                <div class="p-4 text-center text-gray-500 text-sm">
                    <svg class="w-4 h-4 text-gray-400 animate-spin mr-2 inline-block" fill="currentColor">
                        <use href="/icons/sprite.svg#spinner"></use>
                    </svg>{{t "search.searching"}}
                </div>
            </template>
            
            <template x-if="!loading && results.length === 0 && query">
                <div class="p-4 text-center text-gray-500 text-sm">
                    {{t "search.no_results"}} "<span x-text="query"></span>"
                </div>
            </template>
            
            <template x-if="!loading && showingSuggestions">
                <div class="py-2">
                    <div class="px-4 py-2 text-xs font-semibold text-gray-400 dark:text-gray-500 uppercase tracking-wider">
                        {{t "search.quick_links"}}
                    </div>
                    <template x-for="(suggestion, index) in suggestions" :key="index">
                        <div @click="selectSuggestion(suggestion)"
                             @mouseenter="() => {
                                 const prefetchLink = document.createElement('link');
                                 prefetchLink.rel = 'prefetch';
                                 prefetchLink.href = suggestion.url;
                                 document.head.appendChild(prefetchLink);
                             }"
                             :class="selectedIndex === index ? 'bg-blue-50 dark:bg-blue-900/30' : 'hover:bg-blue-50 dark:hover:bg-blue-900/30'"
                             class="px-4 py-3 cursor-pointer border-b border-gray-100 dark:border-gray-700 last:border-b-0 transition-colors">
                            <div>
                                <h4 class="font-semibold text-gray-900 dark:text-gray-100 text-sm" x-text="suggestion.title"></h4>
                                <p class="text-xs text-gray-600 dark:text-gray-400 mt-0.5" x-text="suggestion.description"></p>
                            </div>
                        </div>
                    </template>
                </div>
            </template>
            
                <template x-if="!loading && results.length > 0 && !showingSuggestions">
                    <div class="py-2">
                    <template x-for="(result, index) in results" :key="index">
                        <div @click="selectResult(result)"
                             @mouseenter="() => {
                                 const prefetchLink = document.createElement('link');
                                 prefetchLink.rel = 'prefetch';
                                 prefetchLink.href = result.item.url;
                                 document.head.appendChild(prefetchLink);
                             }"
                             :class="selectedIndex === index ? 'bg-blue-50 dark:bg-blue-900/30' : 'hover:bg-blue-50 dark:hover:bg-blue-900/30'"
                             class="px-4 py-3 cursor-pointer border-b border-gray-100 dark:border-gray-700 last:border-b-0 transition-colors">
                            <div class="flex items-start">
                                <div class="flex-1">
                                    <div class="flex items-center gap-2 mb-1">
                                        <h4 class="font-semibold text-gray-900 dark:text-gray-100 text-sm" x-text="result.item.title"></h4>
                                        <span class="text-xs font-medium px-2 py-0.5 rounded-full"
                                              :class="getCategoryClass(result.item.category)"
                                              x-show="result.item.category"
                                              x-text="result.item.category"></span>
                                    </div>
                                    <p class="text-sm text-gray-600 dark:text-gray-400 mt-1 line-clamp-2" x-text="getSnippet(result)"></p>
                                </div>
                            </div>
                        </div>
                    </template>
                    </div>
                </template>
            </div>
            
            <!-- Category Counter Bar -->
            <template x-if="!loading && results.length > 0 && !showingSuggestions && getCategoryCounts().length > 0">
                <div class="flex-shrink-0 bg-gray-50 dark:bg-gray-900 border-t border-gray-200 dark:border-gray-700 px-4 py-2 rounded-b-lg">
                    <div class="flex items-center justify-center gap-4 text-xs font-medium">
                        <template x-for="cat in getCategoryCounts()" :key="cat.name">
                            <div class="flex items-center gap-1">
                                <span x-text="cat.count" class="font-bold" :class="getCategoryTextClass(cat.name)"></span>
                                <span x-text="getCategoryPlural(cat.name, cat.count)" class="text-gray-500 dark:text-gray-400"></span>
                            </div>
                        </template>
                    </div>
                </div>
            </template>
        </div>
    </div>
</div>
{{end}}