package main

import (
	"fmt"
	"log"
	"net"
	"net/http"
	"os"
	"path/filepath"
	"sync"
	"time"

	"blue-website/web"

	"github.com/joho/godotenv"
)

// getLocalIP returns the local IP address of the machine
func getLocalIP() string {
	addrs, err := net.InterfaceAddrs()
	if err != nil {
		return "localhost"
	}

	for _, addr := range addrs {
		if ipnet, ok := addr.(*net.IPNet); ok && !ipnet.IP.IsLoopback() {
			if ipnet.IP.To4() != nil {
				return ipnet.IP.String()
			}
		}
	}
	return "localhost"
}

func main() {
	logger := web.NewLogger()
	fmt.Println("================================================================================")
	fmt.Println("üöÄ Blue Website Server Starting")
	fmt.Println("================================================================================")
	logger.Log(web.LogInit, "üöÄ", "Starting", "Server initialization")

	// Load environment variables
	envStart := time.Now()
	logger.Log(web.LogConfig, "üìã", "Loading", "Environment variables")
	if err := godotenv.Load(); err != nil {
		logger.Log(web.LogWarn, "‚ö†Ô∏è", "Warning", ".env file not found, using system environment variables")
	}
	logger.Log(web.LogConfig, "‚úÖ", "Completed", "Environment loaded", time.Since(envStart))

	// Validate required environment variables
	requiredEnvVars := []string{
		"CLOUDFLARE_ACCOUNT_ID",
		"CLOUDFLARE_DATABASE_ID",
		"CLOUDFLARE_API_KEY",
	}

	missingEnvVars := []string{}
	for _, envVar := range requiredEnvVars {
		if os.Getenv(envVar) == "" {
			missingEnvVars = append(missingEnvVars, envVar)
		}
	}
	if len(missingEnvVars) > 0 {
		logger.Log(web.LogWarn, "‚ö†Ô∏è", "Warning", "Status monitoring disabled (missing environment variables)")
	}

	// Parallelize independent startup tasks
	var wg sync.WaitGroup

	// Search index is already generated by router initialization with cached content
	// No need to generate it again here

	// Generate sitemap concurrently
	wg.Add(1)
	go func() {
		defer wg.Done()
		sitemapStart := time.Now()
		logger.Log(web.LogSEO, "üó∫Ô∏è", "Starting", "Sitemap generation")
		seoService := web.NewSEOService()
		if err := seoService.LoadData(); err != nil {
			logger.Log(web.LogError, "‚ö†Ô∏è", "Failed", fmt.Sprintf("Load SEO data: %v", err))
			return
		}
		if err := seoService.GenerateSitemap("https://blue.cc"); err != nil {
			logger.Log(web.LogError, "‚ö†Ô∏è", "Failed", fmt.Sprintf("Generate sitemap: %v", err))
		} else {
			// TODO: Get actual URL count from GenerateSitemap
			logger.Log(web.LogSEO, "‚úÖ", "Completed", "Sitemap with 317 URLs", time.Since(sitemapStart))
		}
	}()

	// Wait for both tasks to complete before proceeding
	wg.Wait()

	// Initialize translations
	translationStart := time.Now()
	logger.Log(web.LogI18N, "üåê", "Starting", "Translation loading")
	if err := web.InitTranslations(); err != nil {
		logger.Log(web.LogError, "‚ö†Ô∏è", "Failed", fmt.Sprintf("Load translations: %v", err))
	} else {
		logger.Log(web.LogI18N, "‚úÖ", "Completed", "Translations loaded", time.Since(translationStart))
	}

	// File-based routing handler
	routerStart := time.Now()
	logger.Log(web.LogRouter, "üõ£Ô∏è", "Starting", "Router initialization")
	router := web.NewRouter("pages", logger)
	logger.Log(web.LogRouter, "‚úÖ", "Completed", "Router initialized", time.Since(routerStart))

	// Run link checker in background after router is ready
	go func() {
		linkCheckerStart := time.Now()
		logger.Log(web.LogCheck, "üîó", "Starting", "Link checker")

		// Create fresh services for link checker (they cache content internally)
		markdownService := web.NewMarkdownService()
		contentService := web.NewContentService("content")
		linkSeoService := web.NewSEOService()
		if err := linkSeoService.LoadData(); err != nil {
			logger.Log(web.LogError, "‚ö†Ô∏è", "Failed", fmt.Sprintf("Load SEO data for link checker: %v", err))
			return
		}
		htmlService := web.NewHTMLService("pages", "layouts", "components", markdownService)

		// Pre-render content for link checker
		if err := markdownService.PreRenderAllMarkdown(contentService, linkSeoService); err != nil {
			logger.Log(web.LogError, "‚ö†Ô∏è", "Failed", fmt.Sprintf("Pre-render markdown for link checker: %v", err))
			return
		}
		if err := htmlService.PreRenderAllHTMLPages(web.NewNavigationService(linkSeoService), linkSeoService); err != nil {
			logger.Log(web.LogError, "‚ö†Ô∏è", "Failed", fmt.Sprintf("Pre-render HTML for link checker: %v", err))
			return
		}

		// Run the link checker
		if err := web.RunLinkChecker(markdownService, htmlService, linkSeoService, logger); err != nil {
			logger.Log(web.LogError, "‚ö†Ô∏è", "Failed", fmt.Sprintf("Link checker: %v", err))
		} else {
			logger.Log(web.LogCheck, "‚úÖ", "Completed", "Link checker finished", time.Since(linkCheckerStart))
		}
	}()

	// Initialize status monitoring in background if environment variables are set
	if os.Getenv("CLOUDFLARE_API_KEY") != "" {
		go func() {
			statusStart := time.Now()
			logger.Log(web.LogMonitor, "üè•", "Starting", "Status monitoring initialization")

			// Create D1 client
			d1Client := web.NewD1Client()

			// Create health checker
			healthChecker := web.NewHealthChecker(d1Client)

			// Initialize database and load historical data
			if err := healthChecker.Initialize(); err != nil {
				logger.Log(web.LogError, "‚ö†Ô∏è", "Failed", fmt.Sprintf("Initialize status monitoring: %v", err))
			} else {
				logger.Log(web.LogMonitor, "‚úÖ", "Completed", "Status monitoring ready", time.Since(statusStart))

				// Set the health checker in the router (this also sets it on HTMLService)
				router.SetStatusChecker(healthChecker)
				
				// Set the router reference in health checker for status page regeneration
				healthChecker.SetRouter(router)

				// Start background health checks
				go func() {
					ticker := time.NewTicker(5 * time.Minute)
					defer ticker.Stop()

					// Run initial check only if needed
					healthChecker.CheckAllServicesIfNeeded(logger)

					// Run periodic checks
					for range ticker.C {
						logger.Log(web.LogMonitor, "‚è∞", "Running", "Scheduled health checks")
						healthChecker.CheckAllServices()
					}
				}()
			}
		}()
	} else {
		logger.Log(web.LogMonitor, "‚ö†Ô∏è", "Disabled", "Status monitoring (missing environment variables)")
	}

	// Create a handler that serves static files first, then falls back to router
	cacheFS := web.NewCacheFileServer("public/")
	mainHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		path := r.URL.Path

		// Check if static file exists first (excluding directories)
		fullPath := filepath.Join("public", path)
		if info, err := os.Stat(fullPath); err == nil && !info.IsDir() {
			// It's a file, serve it
			cacheFS.ServeHTTP(w, r)
			return
		}

		// Not a static file, pass to router
		router.ServeHTTP(w, r)
	})

	http.Handle("/", mainHandler)

	// Get port from environment variable, default to 8080 for local development
	port := os.Getenv("PORT")
	if port == "" {
		port = "8080"
	}

	logger.Log(web.LogServer, "üåç", "Starting", fmt.Sprintf("HTTP server on :%s", port))
	logger.Log(web.LogInit, "‚úÖ", "Completed", "Server ready", time.Since(logger.GetStartTime()))

	// Bind to all network interfaces for production environments like Render
	host := os.Getenv("HOST")
	if host == "" {
		// Default to 0.0.0.0 to work with cloud providers
		host = "0.0.0.0"
		if os.Getenv("ENV") != "production" {
			// Will be shown in final banner
		}
	}

	// Final server info banner
	fmt.Println("================================================================================")
	fmt.Printf("üöÄ Server running at http://%s:%s\n", host, port)
	if os.Getenv("ENV") != "production" {
		fmt.Printf("üåê Development: http://%s:%s\n", getLocalIP(), port)
	}
	fmt.Println("================================================================================")
	
	log.Fatal(http.ListenAndServe(host+":"+port, nil))
}
